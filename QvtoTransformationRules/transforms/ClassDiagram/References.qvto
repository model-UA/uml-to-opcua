library References;

import Common.Helpers;

modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype OPCUA uses set('http://opcfoundation.org/UA/2011/03/UANodeSet.xsd');


mapping UML::Generalization::generalization2UAReference() : OPCUA::Reference {
	log("generalization2UAReference: UML element " + self.source->any(0=0).oclAsType(NamedElement).name + " is inherited from UML element " + self.target->any(0=0).oclAsType(NamedElement).name);
	
	assert error (self.target->size() = 1) with log ("Only single inheritance is supported for UML to OPC UA transformation");

	// set attributes of the OPCUA::Reference, self.target should only contain 1 element
	value := self.target->any(0=0).oclAsType(NamedElement).createNodeId();
	referenceType := getIdOrAlias("HasSubtype");
	isForward := false;
}

// TODO: check what happens if the source object and the target object are in different namespaces
mapping UML::Property::property2Reference(inout parent : OPCUA::UANode, inout nodeset : OPCUA::UANodeSetType) : OPCUA::Reference {
	if(self.name <> null) {
		log("property2Reference for UML property " + self.name);
	} else {
		log("property2Reference for unnamed UML property");
	};
	switch {
		case(self.aggregation = UML::AggregationKind::composite or self.aggregation = UML::AggregationKind::shared) {
			var targetClassName := self.type.name;
			var targetObjectTypeNodeId := self.type.createNodeId();

			// Composition or Aggregation are both handled the same way
			// use HasComponent reference for compositions
			referenceType := getIdOrAlias("HasComponent");
			
			// if A isComposedOf B, OPC UA requires to create an UAObject of B and add it to A via a reference
			// note that this object is only created specifically for the OPC UA model but is not present in the UML model
			var targetObjectName : String;
			if(self.name <> null) {
				targetObjectName := self.name.toString();
			} else {
				targetObjectName := targetClassName;
			};
			
			var targetObject := object OPCUA::UAObject{
				nodeId := self.createNodeId(targetObjectName);
				parentNodeId := parent.nodeId;
			};
			
			// the reference points to the newly created object
			value := targetObject.nodeId;

			// add the list of references
			targetObject._references := object OPCUA::ListOfReferences{};
			targetObject._references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasTypeDefinition"); value := targetObjectTypeNodeId};
			targetObject._references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasComponent"); value := parent.nodeId; isForward := false};

			// define modelling rule; note that -1 means infitiy (*); therefore, for 0..* the limits are lower=0 and upper=-1
			var modelingRuleReference := object OPCUA::Reference{referenceType := getIdOrAlias("HasModellingRule")};
			if(self.lower = 0 and self.upper = 1) {
				targetObject.browseName := targetObjectName;
				targetObject.displayName += object OPCUA::LocalizedText{value := targetObject.browseName};
				modelingRuleReference.value := getIdOrAlias("ModellingRule_Optional");
			}
			else if(self.lower = 1 and self.upper = 1) {
				targetObject.browseName := targetObjectName;
				targetObject.displayName += object OPCUA::LocalizedText{value := targetObject.browseName};
				modelingRuleReference.value := getIdOrAlias("ModellingRule_Mandatory");
			}
			else if(self.lower = 0 and self.upper = -1) {
				targetObject.browseName := targetObjectName;
				targetObject.displayName += object OPCUA::LocalizedText{value := targetObject.browseName};
			 	modelingRuleReference.value := getIdOrAlias("ModellingRule_OptionalPlaceholder");
		 	}
		 	else if(self.lower = 1 and self.upper = -1) {
				targetObject.browseName := targetObjectName;
				targetObject.displayName += object OPCUA::LocalizedText{value := targetObject.browseName};
		 		modelingRuleReference.value := getIdOrAlias("ModellingRule_MandatoryPlaceholder");
		 	}
			else {
				modelingRuleReference.value := getIdOrAlias("ModellingRule_MandatoryPlaceholder");
			};
			targetObject._references.reference += modelingRuleReference;
			
			// add the new object to the nodeset
			nodeset.uAObject += targetObject;
		};
		
		case(self.aggregation = UML::AggregationKind::none) { // neither coposition, nor aggregation
			// create a new UAReferenceType if not available yet
			// TODO: check if the reference type has already been created

			assert error (self.association.name <> null) with log ("Unnamed associations are not supported!");
			
			log("Creating new reference type " + self.association.name);
			var newReferenceType := object OPCUA::UAReferenceType {
				nodeId := self.createNodeId(self.association.name);
				browseName := self.association.name;
				displayName := object OPCUA::LocalizedText{value := self.association.name};
			};

			// add the list of references
			newReferenceType._references := object OPCUA::ListOfReferences{};
			newReferenceType._references.reference += object OPCUA::Reference{referenceType := "HasSubtype"; value := getIdOrAlias("NonHierarchicalReferences"); isForward := false};

			// add the new reference type to the nodeset
			nodeset.uAReferenceType += newReferenceType;
			
			value := self.type.createNodeId();
			referenceType := newReferenceType.nodeId; // use the nodeId for now, TODO: add an entry to the alias table
		}
		else {
			raise Exception("Unkown aggregation for property " + self.name + ": " + self.aggregation.toString());
		}
	};
}
