library Classes;

import ClassDiagram.References;
import ClassDiagram.Operations;
import ClassDiagram.Instances;

modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype OPCUA uses set('http://opcfoundation.org/UA/2011/03/UANodeSet.xsd');
modeltype TYPES uses types('http://opcfoundation.org/UA/2008/02/Types.xsd');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');

mapping UML::Class::class2OPCUAObjectType(inout nodeset : OPCUA::UANodeSetType) : OPCUA::UAObjectType {
	log("class2OPCUAObjectType for UML element " + self.name);
	
	// set attributes of the OPCUA::UAObjectType
	browseName := self.createBrowseName();
	nodeId := self.createNodeId();
	displayName := (object OPCUA::LocalizedText {value := browseName})->asOrderedSet();
	
	// create the list of references object
	_references := object OPCUA::ListOfReferences{};
	if(self.ownedElement->selectByType(UML::Generalization)->size() > 0) { //check if the class has any supertypes
		// transform generalizations (i.e. subclass references) of the class
		_references.reference += self.ownedElement->selectByType(UML::Generalization)->map generalization2UAReference();
	} else {
		 // if the class has no other supertypes, use the BaseObjectType as supertype
		_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasSubtype"); value := getIdOrAlias("BaseObjectType"); isForward := false};
	};
	
	// transform primitive properties of the class
	nodeset.uAVariable += self.ownedElement->selectByType(UML::Property)->select(x|x.association = null and x.type.oclIsKindOf(UML::PrimitiveType))->map property2UAVariable(result)->asOrderedSet(); // variables do not have an association field
	
	// transform non-primitive properties of the class
	nodeset.uAObject += self.ownedElement->selectByType(UML::Property)->select(x|x.association = null and not x.type.oclIsKindOf(UML::PrimitiveType))->map property2UAObject(result)->asOrderedSet(); // variables do not have an association field

	// transform associations of the class
	_references.reference += self.ownedElement->selectByType(UML::Property)->select(x|x.association <> null)->map property2Reference(result, nodeset)->asOrderedSet(); // associations do have an association field

	// transform operations of the class
	nodeset.uAMethod += self.ownedElement->selectByType(UML::Operation)->map operation2UAMethod(result, nodeset)->asOrderedSet();
}

mapping UML::Property::property2UAVariable(inout parent : OPCUA::UANode) : OPCUA::UAVariable {
	log("property2UAVariable for UML element " + self.name);

	// set attributs of the OPCUA::UAVariable
	nodeId := self.createNodeId();
	browseName := self.createBrowseName();
	displayName := object OPCUA::LocalizedText{value := browseName};
	
	// set the datatype and maybe the value of the UA::Variable
	if(self.type.toString().find("Int") > 0) {
		dataType := getIdOrAlias("Int32");
		if(self.defaultValue <> null) {
			var feature := TYPES::DocumentRoot.oclAsType(EClass).getEStructuralFeature("int32");
			value := object OPCUA::ValueType1{};
			value.oclAsType(EObject).eSet(feature, self.defaultValue.oclAsType(UML::LiteralInteger).value);
		};		
	} else if (self.type.toString().find("String") > 0) {
		dataType := getIdOrAlias("String");
		if(self.defaultValue <> null) {
			var feature := TYPES::DocumentRoot.oclAsType(EClass).getEStructuralFeature("string");
			value := object OPCUA::ValueType1{};
			value.oclAsType(EObject).eSet(feature, self.defaultValue.oclAsType(UML::LiteralString).value);
		};		
	} else if (self.type.toString().find("Real") > 0 or self.type.toString().find("Double") > 0 or self.type.toString().find("Float") > 0) {
		dataType := getIdOrAlias("Double");
		if(self.defaultValue <> null) {
			var feature := TYPES::DocumentRoot.oclAsType(EClass).getEStructuralFeature("double");
			value := object OPCUA::ValueType1{};
			value.oclAsType(EObject).eSet(feature, self.defaultValue.oclAsType(UML::LiteralReal).value);
		};		
	} else if (self.type.toString().find("Boolean") > 0) {
		dataType := getIdOrAlias("Boolean");
		if(self.defaultValue <> null) {
			var feature := TYPES::DocumentRoot.oclAsType(EClass).getEStructuralFeature("boolean");
			value := object OPCUA::ValueType1{};
			value.oclAsType(EObject).eSet(feature, self.defaultValue.oclAsType(UML::LiteralBoolean).value);
		};		
	} else {
		raise Exception("Unkown datatype for parameter " + self.name + ": " + self.type.toString());
	};
		
	// link the OPCUA::UAVariable to the parent via a HasComponent reference
	parent._references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasComponent"); value := nodeId};
	parentNodeId := parent.nodeId;
	
	// add references
	_references := object OPCUA::ListOfReferences{};
	_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasTypeDefinition"); value := getIdOrAlias("BaseDataVariableType")};
	_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasModellingRule"); value := getIdOrAlias("ModellingRule_Mandatory")}; // TODO replace with correct modelling rule
	_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasComponent"); value := parent.nodeId; isForward := false};
}

// the property is more complex than a simple primitive type or variable, e.g., it represents some state machine
mapping UML::Property::property2UAObject(inout parent : OPCUA::UANode) : OPCUA::UAObject {
	log("property2UAObject for UML element " + self.name);

	// set attributs of the OPCUA::UAObject
	nodeId := self.createNodeId();
	browseName := self.createBrowseName();
	displayName := object OPCUA::LocalizedText{value := browseName};
	
	// link the OPCUA::UAVariable to the parent via a HasComponent reference
	parent._references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasComponent"); value := nodeId};
	parentNodeId := parent.nodeId;
            
	// add references
	_references := object OPCUA::ListOfReferences{};
	_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasTypeDefinition"); value := self.type.createNodeId()}; // it is assumed that the corresponding type (e.g., the class or state machine) is transformed elsewhere
	_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasModellingRule"); value := getIdOrAlias("ModellingRule_Mandatory")}; // TODO replace with correct modelling rule
	_references.reference += object OPCUA::Reference{referenceType := getIdOrAlias("HasComponent"); value := parent.nodeId; isForward := false};
}
